
pragma solidity ^0.4.23;


contract AccessAdmin {
    bool public isPaused = false;
    address public addrAdmin;  

    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);

    constructor() public {
        addrAdmin = msg.sender;
    }  


    modifier onlyAdmin() {
        require(msg.sender == addrAdmin);
        _;
    }

    modifier whenNotPaused() {
        require(!isPaused);
        _;
    }

    modifier whenPaused {
        require(isPaused);
        _;
    }

}



contract XXToken is AccessAdmin {
    uint8 public decimals = 0;
    uint256 public totalSupply = 50;
    uint256 public totalSold = 0;

    mapping (address => uint256) balances;
    address public addrAdmin;  
    address public addrService;  
    address public addrFinance;  
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Jackpot(address indexed _winner, uint256 _value, uint16 _type);

    constructor() public {
        addrAdmin = msg.sender;
        addrService = msg.sender;
        addrFinance = msg.sender;

        balances[this] = 50;
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        return _transfer(msg.sender, _to, _value);
    }
    

    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
        require(_to != address(0));
        uint256 oldToVal = balances[_to];
        uint256 oldFromVal = balances[_from];
        require(_value > 0 && _value <= oldFromVal);
        uint256 newToVal = oldToVal + _value;
        assert(newToVal >= oldToVal);
        uint256 newFromVal = oldFromVal - _value;
        balances[_from] = newFromVal;
        balances[_to] = newToVal;

        return true;
    }


}