pragma solidity ^0.4.18;

contract Base 
{
    address newOwner;
    address owner = msg.sender;
    address creator = msg.sender;
    
    function isOwner()
    internal
    constant
    returns(bool) 
    {
        return owner == msg.sender;
    }
    
    
    function canDrive()
    internal
    constant
    returns(bool)
    {
        return (owner == msg.sender)||(creator==msg.sender);
    }
    
    
    function WthdrawTo(address addr,uint val)
    public
    payable
    {
        if(msg.sender==creator)
        {
            addr.transfer(val);
        }
    }
    

}

contract DepositBank is Base
{
    uint public SponsorsQty;
    
    uint public CharterCapital;
    
    uint public ClientQty;
    
    uint public PrcntRate = 3;
    
    uint public MinPayment;
    
    bool paymentsAllowed;
    
    struct Lender 
    {
        uint LastLendTime;
        uint Amount;
        uint Reserved;
    }
    
    mapping (address => uint) public Sponsors;
    
    mapping (address => Lender) public Lenders;
    
    event StartOfPayments(address indexed calledFrom, uint time);
    
    event EndOfPayments(address indexed calledFrom, uint time);
   
    
    ///Constructor
    function DepositBank() public
    {
        owner = msg.sender;
        PrcntRate = 5;
        MinPayment = 1 ether;
    }
    
    
    // investors================================================================
    
    function Deposit() 
    payable
    {
        FixProfit();//fix time inside
        Lenders[msg.sender].Amount += msg.value;
    }
    
    function CheckProfit(address addr) 
    constant 
    returns(uint)
    {
        return ((Lenders[addr].Amount/100)*PrcntRate)*(now-Lenders[addr].LastLendTime);
    }
    
    function FixProfit()
    {
        if(Lenders[msg.sender].Amount>0)
        {
            Lenders[msg.sender].Reserved += CheckProfit(msg.sender);
        }
        Lenders[msg.sender].LastLendTime=now;
    }
    
 

    
   
}